important variables:
w: width of the plate
l: length of the plate
n: current node (1 to lw)
edge: the edges bordered by the current node (1 indicates yes and 0 indicates no, top=0, right=1, bottom=2, left=3)
MAT: the main, big matrix (lw by lw)
C: the smaller, constant matrix (l by w)
T: the matrix for current temperatures (l by w)
Q: Boundary condition array, each value corresponds to the flux through an
	edge ie [q_top, q_right, q_bottom, q_left] where if the edge is constant
	T then the corresponding value is 0 in the array
Relevant constants for equations

functions:

check_location:
	checks the location of the node
	inputs: w, l, n
	output: edge matrix
interior_step:
	appends rows to the matrices for interior nodes
	inputs: relevant constants for equation, MAT, C, T, n
	output: updated matrices

edge_step:
	appends rows to the matrices for the edge nodes 
	inputs: relevant constants for equation, MAT, C, T, Q, n, edge value
	output: updated matrices

corner_step:
	appends rows to the matrices for the corner nodes
	inputs: relevant constants for equation, MAT, C, T, Q, n, corner value
	output: updated matrices

check_location(){
	%use lori's code
}

interior_step(){
	%determine neighboring nodes
	%create row for matrices using equation and neighboring nodes
	%append new row to old matrices using command: [old_matrix; new_row]
}

edge_step(){
	%determine neighboring nodes
	%if relevant q value == 0, create row for matrices using equation and neighboring nodes
	%else, create row for matrices using equation and neighboring nodes
	%append new row to old matrices using command: [old_matrix; new_row]

}

%same for corner_step()

main(){

	%define all important variables

	for (time steps){
		for(number of nodes){

			location = check_location(node)

			if (sum(edge)==0){
				interior_step(node)
			}

			else if (sum(edge)==1){
				edge_step(node)
			}
			
			else if (sum(edge)==2){
				corner_step(node)
			}
		}
		Temperatures = inv(MAT)*C;

		% rearrange temperature matrix and graph
	}
}
